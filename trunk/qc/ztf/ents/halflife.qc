
//.string areaname;
//.float material;
//string _delaydata;
.string LightningEnd;
.string LightningStart;
.vector rendercolor;
//.float renderamt;
.string LaserTarget;

void info_target () {
};

void item_healthkit () {
    self.origin_z = self.origin_z + 40;
    item_health ();
};

void() lightning_fire = {
    entity te;
    te = find (world,targetname,self.LaserTarget);
    if (te) {
        sound (self,2,"misc/power.wav",1,1);
        WriteByte (4,23);
        WriteByte (4,6);
        WriteEntity(4, self);
        WriteCoord (4, self.origin_x);
        WriteCoord (4, self.origin_y);
        WriteCoord (4, self.origin_z);
        WriteCoord (4, te.origin_x);
        WriteCoord (4, te.origin_y);
        WriteCoord (4, te.origin_z);
        multicast (self.origin ,1);
    } else {
        dprint (te.classname);
        dprint (" missing laser targets\n");
    }
};

void laser_use () {
    if (self.spawnflags & 1) {
        lightning_fire();
        self.spawnflags = (self.spawnflags - 1);
    } else {
        SUB_Null();
        self.spawnflags = (self.spawnflags + 1);
    }
};

void env_laser () {
    //dremove(self);
    self.use = laser_use;
};

void Explode () {
    WriteByte (4,23);
    WriteByte (4,3);
    WriteCoord (4,self.origin_x);
    WriteCoord (4,self.origin_y);
    WriteCoord (4,self.origin_z);
    multicast (self.origin,1);
};

void env_explosion () {
    self.use = Explode;
};

void env_glow () {
    dremove(self);
};

void () FadeUse {
    eprint(activator);
}

void env_fade () {
    self.use = FadeUse;
};

void env_beam_use () {
    if ( (self.spawnflags & 1) ) {
        self.solid = 0;
        setmodel (self, string_null);
        self.spawnflags = (self.spawnflags - 1);
    } else {
        self.solid = 1;
        setmodel (self,self.mdl);
        self.spawnflags = (self.spawnflags + 1);
    }
};

void beam_delayed_spawn () {
    vector orgStart;
    vector orgEnd;
    entity te;
    te = find( world, targetname,self.LightningStart);
    if (te != world) {
        //dprint("found start\n");
        orgStart = te.origin;
    }
    te = find( world, targetname, self.LightningEnd);
    if (te != world) {
        orgEnd = te.origin;
        //dprint("found end\n");
    }
    if (orgStart)
        setorigin(self, orgStart);
    self.angles = vectoangles (orgEnd - orgStart);
    //self.angles = vectoangles (orgEnd);
    self.think = SUB_Null;
};

void env_beam () {
    self.solid = 1;
    self.movetype = 5;
    if ( self.mdl ) {
        precache_model (self.mdl);
    } else {
        precache_model ("progs/beam.mdl");
        self.mdl = "progs/beam.mdl";
        //if (self.team_no = 2.000
    }
    //beams have a set destination in code and generated by
    //each vector specified in halflife. Unfortunately this
    //isnt a feature i have so we must be a bit dodgy and
    //use a beam model and try to correct its orientation
    self.use = env_beam_use;
    self.think = beam_delayed_spawn;
    self.nextthink = (time + 3);
    if (self.rendercolor_z < self.rendercolor_x)
        self.skin = 1;
    if (self.spawnflags & 1) {
        setmodel (self,self.mdl);
    }
};

void Item_Use () {
    if ( (self.use != SUB_Null) ) {
        if ( self.use ) {
            self.use ();
        }
    }
};

void Delayed_Use () {
    entity t;
    entity ste;
    t = find (world,targetname, self.target);
    if ( t ) {
        //bprint(PRINT_HIGH, t.classname, " delayed 2\n");
        ste = self;
        self = t;
        if ( (self.use != SUB_Null) ) {
            if ( self.use ) {
                self.use ();
            }
        }
        self = ste;
    }
    //else
    // {
    //    bprint(PRINT_HIGH,t.target);
    //    bprint(PRINT_HIGH,"  ");
    //    bprint(PRINT_HIGH, t.classname, " not found \n");
    //}
};

void multi_spawn () {
    string key;
    string value;
    float args;
    entity t;
    entity timer;
    float stlen;
    string st;
    tokanize(self.netname);
    args = argc() - 2;
    while (args>0) {
        key = (argv(args - 1));
        value = (argv(args));
        if ((((key != "classname") && (key != "targetname")) && (key != "origin"))) {
            self.target = key;
            self.delay = stof(value);
            st = strstr (key, "#1");
            if (st != string_null) {
                stlen = strlen (key);
                key = substr(self.target , 0 , stlen - 2);
            }
            //  bprint(PRINT_HIGH,key);
            //  bprint(PRINT_HIGH,"  ");
            //  bprint(PRINT_HIGH, ftos(stlen), "\n");
            if (self.delay) {
                if (stlen) {
                    timer = spawn ();
                    timer.classname = "DelayedTimer";
                    timer.target = newstr(key, stlen);
                    timer.nextthink = (time + self.delay);
                    timer.think = Delayed_Use;
                } else {
                    t = find (world,targetname, key);
                    if ( t ) {
                        t.nextthink = (time + self.delay);
                        t.think = Item_Use;
                    }
                }
            } else {
                SUB_UseTargets();
            }
            stlen = 0;
        }
        args = args - 2;
    }
};

void multi_manager () {
    if (__fullspawndata != "") {
        dprint("MULTI MANAGER spawned!\n");
        self.use = multi_spawn;
        self.netname = __fullspawndata;
    } else
        dprint("no server support for multi_manager\n");
};

void bomb_target_touch () {
    if (!modetype & 4) return;
    if (other.is_detpacking) {
        TeamFortress_SetBomb(other);
        other.target = self.target;
    }
};

void SplashTouch () {
    if (other.classname != "player") return;
    other.watertype = -3;
    other.waterlevel = 1;
};

void func_water () {
    if (mapname == "openfire" || mapname == "tfc_openfire")
        dremove(self);
    self.solid = 1;
    self.movetype = 0;
    //setorigin (self,self.origin);
    setmodel (self,self.model);
    self.touch = SplashTouch;
};

void() func_ladder = {
    self.movetype = 0;
    self.solid = 5;
    setmodel(self, self.model);
    self.model = "";
};

void () Breakaway  = {
    self.solid = 0;
    setmodel (self,string_null);
};

void Breakuse () {
    if ( (self.spawnflags & 1) ) {
        Breakaway();
        self.spawnflags = (self.spawnflags - 1);
    } else {
        self.solid = 4;
        setmodel (self,self.mdl);
        self.spawnflags = (self.spawnflags + 1);
    }
};

void Breaktouch () {
    if (other.classname != "player") return;
    Breakaway();
};

void func_breakable () {
    self.solid = 4;
    self.movetype = 7;
    setorigin (self, self.origin);
    self.mdl = self.model;
    setmodel (self, self.mdl);
    setsize (self, self.mins , self.maxs);
    if (self.spawnflags & 1) {
        if (self.targetname)
            self.use = Breakuse;
    } else {
        if (self.health) {
            self.takedamage = 1;
            self.th_die = Breakaway;
        }
    }
    if (self.spawnflags & 2) {
        self.touch = Breaktouch;
    }
};

void func_wall_toggle () {
    self.movetype = 7;
    self.solid = 4;
    if (self.targetname)
        self.use = Breakuse;
    self.mdl = self.model;
    setmodel (self,self.mdl);
    self.spawnflags = 1;
};

void info_areadef () {
    dremove(self);
};

void infodecal () {
    dremove(self);
};

void trigger_camera () {
    self.classname = "info_player_start";
};
